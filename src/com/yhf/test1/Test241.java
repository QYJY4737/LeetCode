package com.yhf.test1;

import java.util.Arrays;
import java.util.Scanner;

/**
 * Created on 2023/8/15.
 *
 * @author qyjy4737
 */
public class Test241 {
    /**
     * 题目0241-组合出合法最小数
     * 题目描述
     * 给一个数组，数组里面哦都是代表非负整数的字符串，将数组里所有的数值排列组合拼接起来组成一个数字，输出拼接成的最小的数字。
     * <p>
     * 输入描述
     * 一个数组，数组不为空，数组里面都是代表非负整数的字符串，可以是0开头，例如：["13", "045", "09", "56"]。
     * 数组的大小范围：[1, 50]
     * 数组中每个元素的长度范围：[1, 30]
     * <p>
     * 输出描述
     * 以字符串的格式输出一个数字，
     * <p>
     * 如果最终结果是多位数字，要优先选择输出不是“0”开头的最小数字
     * 如果拼接出来的数字都是“0”开头，则选取值最小的，并且把开头部分的“0”都去掉再输出
     * 如果是单位数“0”，可以直接输出“0”
     * 示例一
     * 输入
     * 20 1
     * 输出
     * 120
     * 示例二
     * 输入
     * 08 10 2
     * 输出
     * 10082
     * 示例三
     * 输入
     * 01 02
     * 输出
     * 102
     * 思路解析和复杂度分析
     * 这道题目的关键在于找出一个适当的排序规则，使得所有数字按照这个规则排序后，按顺序连接得到的数字最小。观察可以发现，如果两个数字 x 和 y，连接成 xy 和 yx，如果 xy < yx，则在最终的结果中，x 应该在 y 前面。因此，我们可以定义这样的比较函数，并以此为规则对所有数字进行排序。
     * <p>
     * 然后，按照排序结果依次将每个数字连接起来即可。
     * <p>
     * 在具体的实现过程中，我们需要处理一些特殊情况。例如，当输入的所有数字都是 0 时，我们应该输出一个单独的 0，而不是一串 0。因此，在实现时，可以在输出结果前检查排序后的第一个数字是否为 0，如果是，则直接输出 0。
     * <p>
     * 对于时间复杂度，假设输入的数字总位数为 n，我们需要 O(n log n) 的时间进行排序。由于我们只进行了一次遍历，所以连接所有数字的时间复杂度是 O(n)。因此，总的时间复杂度是 O(n log n)。
     * <p>
     * 对于空间复杂度，我们只需要存储输入的所有数字，所以空间复杂度是 O(n)。
     * <p>
     * 这个解法的优点是逻辑清晰，易于理解，且实现起来较为简单。但是，如果输入的数字总位数非常大，可能会导致排序时间较长。在实际使用时，可以根据具体需求和性能要求进行优化。
     */

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        String[] arr = new String[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.next();
        }
        scanner.close();

        // 使用 Arrays.sort 进行排序，利用lambda表达式自定义排序规则
        Arrays.sort(arr, (a, b) -> (a + b).compareTo(b + a));

        // 将排序后的数组进行拼接并输出
        StringBuilder sb = new StringBuilder();
        for (String s : arr) {
            sb.append(s);
        }
        System.out.println(sb.toString());
    }
}
