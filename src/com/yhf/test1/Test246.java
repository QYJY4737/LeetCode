package com.yhf.test1;

import java.util.Scanner;

/**
 * Created on 2023/8/15.
 *
 * @author qyjy4737
 */
public class Test246 {
    /**
     * 题目0246-需要打开多少监控器
     * 题目描述
     * 某长方形停车场，每个车位上方都有对应监控器，当且仅当在当前车位或者前后左右四个方向任意一个车位范围停车时，监控器才需要打开，给出某一时刻停车场的停车分布，请统计最少需要打开多少个监控器
     * <p>
     * 输入描述
     * 第一行输入m，n表示长宽，满足1<m,n<=20;后面输入m行，
     * 每行有n个0或1的整数，整数间使用一个空格隔开，
     * 表示该行已停车情况，其中0表示空位，1表示已停
     * <p>
     * 输出描述
     * 最少需要打开监控器的数量;
     * <p>
     * 示例一
     * 输入
     * 3 3
     * 0 0 0
     * 0 1 0
     * 0 0 0
     * 输出
     * 1
     * 思路解析和复杂度分析
     * 思路解析
     * 这道题目的主要思路是进行一次扫描遍历，检查每个停车位的状态。如果停车位上停有车（值为1），则将其自身以及上下左右四个方向的车位都标记为需要监控（将值设为1）。注意，由于题目限定的输入格式，我们需要在原始的停车场地图外面添加一圈边界，以方便处理边界车位的情况。为了方便计算上下左右四个方向，我们预先定义一个方向数组，其中包含了当前位置与四个方向偏移的坐标变化量。
     * <p>
     * 在扫描遍历并标记需要监控的车位之后，我们再进行一次遍历，统计需要监控的车位的数量（即值为1的车位的数量），并将结果输出。
     * <p>
     * 复杂度分析
     * 时间复杂度：由于我们进行了两次对停车场的遍历，每次遍历的时间复杂度都是O(mn)，其中m和n分别是停车场的长和宽。因此，整个程序的时间复杂度为O(mn)。
     * <p>
     * 空间复杂度：我们使用了一个二维数组来存储停车场的状态，其大小为(m+2)*(n+2)，所以空间复杂度为O(mn)。
     * <p>
     * 由于m和n的上限为20，所以这个算法在时间和空间上都是十分高效的。
     */

    static int m, n;
    static int[][] a = new int[25][25];
    static int[][] dirs = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}, {0, 0}};

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        m = scanner.nextInt();
        n = scanner.nextInt();
        for (int i = 1; i <= m; i++)
            for (int j = 1; j <= n; j++)
                a[i][j] = scanner.nextInt();

        int ans = 0;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                for (int[] dir : dirs) {
                    int x = i + dir[0];
                    int y = j + dir[1];
                    if (x >= 1 && x <= m && y >= 1 && y <= n && a[x][y] == 1) {
                        ans++;
                        break;
                    }
                }
            }
        }

        System.out.println(ans);
    }
}
