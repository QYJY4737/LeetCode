package com.yhf.test1;

import java.util.Scanner;

/**
 * Created on 2023/8/15.
 *
 * @author qyjy4737
 */
public class Test239 {
    /**
     * 题目0239-二元组个数
     * 题目描述
     * 给定两个数组a，b，若a[i] == b[j] 则称 [i, j] 为一个二元组，求在给定的两个数组中，二元组的个数。
     * <p>
     * 输入描述
     * 第一行输入 mmm；
     * 第二行输入 mmm 个数，表示第一个数组；
     * 第三行输入 nnn；
     * 第四行输入 nnn 个数，表示第二个数组。
     * <p>
     * 输出描述
     * 输出符合要求的二元组个数。
     * <p>
     * 示例一
     * 输入
     * 4
     * 1 2 3 4
     * 1
     * 1
     * 输出
     * 1
     * 说明
     * 二元组个数为 1个。
     * <p>
     * 示例二
     * 输入
     * 6
     * 1 1 2 2 4 5
     * 3
     * 2 2 4
     * 输出
     * 5
     * 说明
     * 二元组个数为 5 个。
     * <p>
     * 思路解析和复杂度分析
     * 这个问题的关键在于查找两个数组中相等的元素对的数量。我们可以通过遍历两个数组来解决这个问题。
     * <p>
     * 算法思路：
     * 首先，我们需要读取两个数组的长度和它们的元素。然后，我们使用两个循环遍历这两个数组，其中外层循环遍历数组a，内层循环遍历数组b。在每次迭代中，我们都检查当前元素是否相等。如果相等，我们就增加计数器的值。最后，我们打印出计数器的值，这就是我们要找的二元组的数量。
     * <p>
     * 这个算法的核心思想是使用双重循环来遍历所有可能的元素对，然后通过比较它们的值来判断是否需要增加计数器的值。通过这种方法，我们可以确保不会错过任何一个有效的二元组。
     * <p>
     * 复杂度分析：
     * 时间复杂度：该算法的时间复杂度是O(m*n)，其中m和n分别是两个数组的长度。这是因为我们需要遍历两个数组中的每一个元素。
     * <p>
     * 空间复杂度：该算法的空间复杂度是O(1)，因为我们只使用了固定数量的变量，包括两个用于存储数组长度的变量，两个用于遍历数组的变量，以及一个用于计数的变量。这些变量的数量不会随着输入大小的增加而增加。
     * <p>
     * 总的来说，这个算法是一个简单而有效的解决方案。它只需要简单的遍历和比较操作，因此在处理大型数据时也能保持良好的性能。
     */

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        int[] a = new int[m];
        for (int i = 0; i < m; i++) {
            a[i] = scanner.nextInt();
        }

        int n = scanner.nextInt();
        int[] b = new int[n];
        for (int i = 0; i < n; i++) {
            b[i] = scanner.nextInt();
        }

        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (a[i] == b[j]) {
                    count++;
                }
            }
        }

        System.out.println(count);
    }
}
