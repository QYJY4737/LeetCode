package com.yhf.test1;

import java.util.Scanner;

/**
 * Created on 2023/8/15.
 *
 * @author qyjy4737
 */
public class Test219 {
    /**
     * 题目0219-查找充电设备组合
     * 题目描述
     * 某个充电站，可提供 nnn 个充电设备，每个充电设备均有对应的输出功率。
     * 任意个充电设备组合的输出功率总和，均构成功率集合 PPP 的1个元素。
     * 功率集合 PPP 的最优元素，表示最接近充电站最大输出功率 p_max 的元素。
     * <p>
     * 输入描述
     * 输入为三行：
     * 第一行为充电设备个数 nnn。
     * 第二行为每个充电设备的输出功率。
     * 第三行为充电站最大输出功率 p_max。
     * <p>
     * 输出描述
     * 功率集合 PPP 的最优元素
     * <p>
     * 备注
     * 充电设备个数 n>0n > 0n>0
     * 最优元素必须小于或等于充电站最大输出功率 p_max。
     * 示例一
     * 输入
     * 4
     * 50 20 20 60
     * 90
     * 输出
     * 90
     * 说明
     * 当充电设备输出功率50、20、20组合时，其输出功率总和为90，最接近充电站最大充电输出功率，因此最优元素为90。
     * <p>
     * 示例二
     * 输入
     * 2
     * 50 40
     * 30
     * 输出
     * 0
     * 说明
     * 所有充电设备的输出功率组合，均大于充电站最大充电输出功率30，此时最优元素值为0。
     * <p>
     * 思路解析和复杂度分析
     * 解题思路
     * 本题的目标是找到充电设备组合的输出功率总和，使其最接近充电站的最大输出功率。为了解决这个问题，我们可以遍历所有可能的充电设备组合，计算每个组合的输出功率总和，并找到最接近充电站最大输出功率的组合。为了遍历所有可能的充电设备组合，我们可以使用深度优先搜索（DFS）算法。
     * <p>
     * DFS算法通过递归的方式遍历每个充电设备，探索它们的所有子集。在递归过程中，我们可以选择一个充电设备，将其输出功率添加到当前总和中，然后继续递归到下一个设备；或者跳过这个充电设备，不将其输出功率添加到当前总和中，继续递归到下一个设备。当我们遍历到设备数组的末尾时，我们检查当前的输出功率总和是否小于或等于充电站的最大输出功率，如果满足条件且大于当前的最佳总和，则更新最佳总和。最后，返回遍历结束时找到的最佳总和。
     * <p>
     * 复杂度分析
     * 时间复杂度：由于我们使用DFS算法遍历了所有可能的充电设备组合，这导致时间复杂度为O(2n)，其中n是充电设备的数量。在最坏情况下，当n等于输入限制的最大值时，时间复杂度将达到O(250)，这在现实中是不可行的。然而，实际问题中充电设备的数量通常不会过大，因此这个算法在实际应用中仍然是可行的。
     * <p>
     * 空间复杂度：由于我们使用递归实现DFS算法，空间复杂度主要取决于递归栈的深度。在这种情况下，递归栈的深度等于充电设备的数量，因此空间复杂度为O(n)。
     * <p>
     * 优化
     * 由于本题的时间复杂度较高，可以考虑使用动态规划或回溯算法来优化时间性能。动态规划可以通过构建一个表格来记录子问题的解，从而避免重复计算相同子问题。回溯算法可以在搜索过程中剪枝，排除掉不可能产生最优解的部分解空间，从而减少搜索空间。但这些优化方法在实现上可能会更复杂，可能需要额外的数据结构和算法设计。
     */

    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(System.in)) {
            int n = scanner.nextInt();

            int[] p = new int[n];
            for (int i = 0; i < n; i++) {
                p[i] = scanner.nextInt();
            }

            int p_max = scanner.nextInt();
            System.out.println(solution(n, p, p_max));
        }

    }

    public static int solution(int n, int[] p, int p_max) {
        int[][] dp = new int[n + 1][p_max + 1];

        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= p_max; j++) {
                if (i == 0 || j == 0) continue;

                if (p[i - 1] > j) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], p[i - 1] + dp[i - 1][j - p[i - 1]]);
                }
            }
        }

        return dp[n][p_max];
    }
}
